---
title: linux笔记
date: 2019-04-10 22:24:40
tags: linux
categories: linux
---
本文为某天晚上阅读《鸟哥的Linux私房菜》第11章时著，读者可以自行查阅原版书籍。
<!-- more -->
题外话：markdown的换行必须在前一行的末尾加两个空格  
本文为晚上阅读《鸟哥的Linux私房菜》第11章时著，读者可以自行查阅原版书籍。
# shell和shell script
## 变量
- 双引号包住的符号可以保持原来的特性  
- 比如“var="lang is $LANG"”  
```
echo $var
```
  可以得到  lang is zh_CN.UTF-8  
 - 用斜单引号把命令括起来然后赋值给变量，变量的值是单引号里的命令的返回结果  
 比如var=`pwd`，那var的值就是执行pwd的结果，也就是当前路径。
- 子进程只会集成父进程的环境变量，而不会继承父进程的自定义变量。
- 但是可以用“export 变量名”的方式把自定义变量变成环境变量，这样子进程就能使用该变量了。  
- 自定义变量 = 局部变量; 环境变量 = 全局变量
- declare [-aixr] variable  
-a 把变量设置成数组  
-i 把变量设置成整型  
-x 把变量设置成环境变量
-r 把变量设置成只读变量

## read
read [-pt] 变量名  
-p "提示内容"
-t [限定时间]  
比如
```
read -p "please input your name" -t 30 name
```
在屏幕上打出“"please input your name"”提示用户在30秒内输入名字（如果30秒内没有输入，将结束进程，不再等待）

## declare和typeset
执行
```
sum=1+2+3  
echo $sum
```
会发现输出的是“1+2+3”而不是6，因为这个变量类型是文字
执行
```
declare -i sum=1+2+3
echo $sum
```
就会输出6，因为这里的sum是整型的  
**注：linux中的运算最多仅能达到整型，1/3=0**

## 数组类型
var[index]=content
```
var[0]=small
var[1]=middle
var[2]=big
echo "${var[0]}, ${var[1]}, ${var[2]}"
```
输出：small, middle, big  
*一般来说，建议以${}的形式读取数组更精准无误*

## ulimit
ulimit [-SHacdfltu]  
-a, 列出目前身份的所有限制数据数值  
-f [配额] 设置此shell可以创建的最大文件容量

## 变量内容的删除、替代与替换
这里涉及到了通配符的知识，可以跳到本篇笔记的后面去看。
```
${变量#关键字}     #若变量从头开始的数据符合“关键字”，则将符合的最短数据删除
${变量##关键字}     #若变量从头开始的数据符合“关键字”，则将符合的最长数据删除
${变量#%关键字}     #若变量从尾向前的数据符合“关键字”，则将符合的最短数据删除
${变量#%%关键字}     #若变量从尾向前的数据符合“关键字”，则将符合的最长数据删除
```
例子(书上的例子不是太好懂，我重新举了例子)  
#和##的例子 
```
bash-3.2$ a=12345678:1234:abcde:    #给a赋这么一大串值
bash-3.2$ echo ${a#1*3}     #删除满足从头开始满足1*3的内容，删最短的。其实也就是开头的123，所以输出结果如下
45678:1234:abcde:
bash-3.2$ echo ${a##1*3}    #删除满足从头开始满足1*3的内容，删最长的。跟上面不同的是，这里要删的从1开始，一直找到了'12345678'这个串中的‘3’所以就把12345678:123全删除了。结果如下
4:abcde:
```
%和%%的例子  
```
bash-3.2$ a=12345678:45678:
bash-3.2$ echo ${a%6*8:}    # 从后往前匹配到‘6*8:’就删了
12345678:45
bash-3.2$ echo ${a%%6*8:} #也是从后往前匹配'6*8:'但明显从'12345678'中的'6'匹配到最末尾的'8:'是最长的，所以最后只剩下前缀12345了
12345
```
(这一节感觉不太好懂，我第二遍才看懂的，不过弄懂了很开心hhh)


## 命令别名设置：alias, unalias
alias  别名=原始命令
```
alias l='ls -a'
```
之后执行`l`的效果就等同于`ls -a`  

history会列出bash执行过的所有命令  
参数  
n 列出最近n条命令  
-c 把所有history的内容全部删除  
-a 将目前新增的history命令加入histfiles中，如果不存在的话就写入~/.bash_history
## Bash shell的操作环境

### 路径与命令查找顺序  
当我们执行某个命令时，命令运行的顺序如下
1. 以相对或者绝对路径执行命令
2. 由alias找到该命令执行
3. 由bash内置的buitin命令执行
4. 通过$PATH这个变量的顺序找到第一个命令来执行

### bash的环境配置文件

login shell
(还是没看懂)
## 通配符与特殊符号
``` 
* 0到无穷个任意字符  
? 一定有一个任意字符  
[] 一定有一个中括号里的任意字符
[-] 编码顺序内的所有字符，比如[1-9]，表示一定有1~9
[^abc] 表示只要一个字符不是abc中的任意一个就OK
```
## 数据重定向
### 标准输出重定向
注：1>等价于>  
1>>等价于>>  
因为>和>>的默认代码是1
```
命令>文件名
```
这样所执行命令的正确输出就会写入到给定的文件中。  
**注意：>的左右没有空格**
```
命令>>文件名
```
如果执行>，那么文件会被重写，但如果是>>，正确输出就会追加到给定文件中

### 错误输出重定向
```
命令2>文件名
```
以覆盖的形式将错误数据写入到给定文件中  
注：这里2>是固定不变的命令，命令和文件名可以是任意的  


### 正确输入重定向

PS: 明天再写 2019.4.10
